# The different colored species particles
# The species follow a simple (unrealistic) cyclic ecology.
# The species number is prefixed by "/=".
NOUN _ 0 0 0
NOUN .*/=0 255 0 0
NOUN .*/=1 255 81 0
NOUN .*/=2 255 161 0
NOUN .*/=3 255 242 0
NOUN .*/=4 188 255 0
NOUN .*/=5 107 255 0
NOUN .*/=6 27 255 0
NOUN .*/=7 0 255 54
NOUN .*/=8 0 255 134
NOUN .*/=9 0 255 215
NOUN .*/=10 0 215 255
NOUN .*/=11 0 134 255
NOUN .*/=12 0 54 255
NOUN .*/=13 27 0 255
NOUN .*/=14 107 0 255
NOUN .*/=15 188 0 255
NOUN .*/=16 255 0 242
NOUN .*/=17 255 0 161

# The tools and behavior accessible to the player
NOUN wall/1 43 43 43
NOUN wall/2 85 85 85
NOUN wall/3 128 128 128
NOUN wall/4 170 170 170
NOUN wall/5 213 213 213
NOUN cement 255 255 255
NOUN acid 64 64 64
NOUN perfume 128 64 84
NOUN mutator 255 128 168
NOUN lava 255 96 96
NOUN lava/.* 224 96 96
NOUN wall/basalt 255 200 0
NOUN zoo_guest.* 254 254 254

# Beacon: an example directional particle
NOUN (beacon|photon).* 192 192 0
VERB beacon _ beacon photon/$F .5 shine
VERB beacon _ _ _ .01 extinguish
VERB photon/$F _ $T $S 1 beam
VERB photon/$F [^_].* _ $T .9 absorb
VERB photon/$F [^_].* photon/$++L $T .1 reflect
VERB photon/$F [^_].* photon/$++R $T .05 reflect
# Without this last rule, photons at uncrossable borders will never die
VERB photon/$B .* _ $T .001 scatter

# Initial conditions
VERB /INIT.* _ beacon _ 1 /start
#VERB /INIT.* _ _ _ 1 /start

# Animal rules. This is where the ecology actually happens.
# Successful predation
VERB .*/=(\d+) .*/=$%18+1.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+2.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+3.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+4.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+5.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+6.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+7.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+8.1 $S $S .024 eat
VERB .*/=(\d+) .*/=$%18+9.1 $S $S .024 eat

# Unsuccessful predation
VERB .*/=(\d+) .*/=$%18+1.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+2.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+3.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+4.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+5.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+6.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+7.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+8.1 $S _ .006 kill
VERB .*/=(\d+) .*/=$%18+9.1 $S _ .006 kill

# Breeding, overcrowding
VERB .*/=\d+ _ $S $S .0007 spawn
VERB .*/=\d+ .*/=\d+ _ $T 0.0015 choke

# Movement
VERB .*/=\d+ _ $T $S 0.02 step

# Other behaviors of animals
# Animals eat guests:
VERB .*/=\d+ zoo_guest.* _ $S 1.0 maul
# Imps feed on lava:
VERB .*_imp/=\d+ lava.* $S $S .01 frolic



# Walls and cement
VERB wall/([2-9a-z]) .* wall/$-1 $T .00022 decay
VERB wall/([2-9a-z]) wall.* wall/$-1 $T .00018 decay
VERB wall/([2-9a-z]) acid wall/$-1 $T 0.001 decay
VERB wall/1 .* _ $T 2.2E-4 decay
VERB wall/1 wall.* _ $T .00018 decay
VERB wall/1 acid _ $T 0.001 decay
VERB cement [^_].* wall/4 $T 0.2 set
VERB cement wall.* wall/4 $T 0.9 stick
VERB cement _ $T $S .99 drift
VERB cement .* _ $T .01 drain


# Cage builders: a simple geometric program with nested loops (bricks/walls).
NOUN cage_builder.* 128 128 192
# Choose size and orientation:
VERB cage_builder .* cage_builder/len:5 $T .3 plan_small_cage
VERB cage_builder .* cage_builder/len:11 $T .3 plan_medium_cage
VERB cage_builder .* cage_builder/len:21 $T .3 plan_large_cage
VERB cage_builder/len:([^,]*) .* cage_builder/len:$1,dir:$F $T 1 choose_orientation
# Exclude diagonal cages (or animals can escape through the cracks)
VERB cage_builder/len:([^,]*),dir:(ne|nw|se|sw) .* cage_builder/len:$1,dir:$F $T 1 rethink_orientation
# OK, here's the program that actually builds the cage. It's a simple state machine: build, turn, stop.
VERB cage_builder/len:([^,]*),dir:([^,]) .* cage_builder/len:$1,walls:3,steps:$1,dir:$2 $T 1 start
VERB cage_builder/len:(.*),walls:(.),steps:([^0].*),dir:$F _ wall/5 cage_builder/len:$1,walls:$2,steps:$-3,dir:$F 1 place_next_brick
VERB cage_builder/len:(.*),walls:([^0]),steps:0,dir:$F .* cage_builder/len:$1,walls:$-2,steps:$1,dir:$+R $T 1 build_next_wall
VERB cage_builder/len:(.*),walls:0,steps:[01],dir:.* .* wall/5 $T 1 finish
# Handle collisions gracefully:
VERB cage_builder/.*dir:$F wall/.*|cage_builder.* wall/5 $T 1 join_wall


# uncomment the following to test for runaway particle names... (cage_builder discovered this bug, that's why it's here)
# VERB cage_builder/(.*) .* $S$1 $T 1 example_regex_bug


# Acid dissolves everything; usually, it is then "used up"
VERB acid .* $S _ 0.1 dissolve
VERB acid .* _ _ 0.9 dissolve
# Override "Acid dissolves everything" rules for basalt, lava & empty space
VERB acid wall/basalt|lava|_ $S _ 0.0 dissolve
VERB acid wall/basalt|lava|_ _ _ 0.0 dissolve
# Instead, acid turns basalt into lava
VERB acid wall/basalt $S lava 0.3 dissolve
# Acid does fast Brownian motion
VERB acid _ $T $S 1.0 drift
VERB acid .* _ $T .005 drain

# Perfume
VERB perfume .*/=\d+ $T $T 1.0 hornify
VERB .*/=\d+ perfume $S $S 1.0 breed
VERB perfume _ _ $T 0.1 disperse
VERB perfume _ $S $S 0.09 billow
VERB perfume _ $T $S 0.81 drift

# Mutator gas: change the species number.
VERB mutator (.*)/=(\d+) _ mutant/=$%18+1.2 1.0 mutate
VERB mutator (.*)/=(\d+) _ mutant/=$%18+17.2 1.0 mutate
VERB mutator (.*)/=(\d+) _ mutant/=$%18+2.2 0.1 mutate
VERB mutator (.*)/=(\d+) _ mutant/=$%18+16.2 0.1 mutate
VERB mutator _ _ _ 0.1 disperse
VERB mutator _ $T $S 0.9 drift
VERB mutator perfume $T $T 1.0 react

# Lava. Sticks around longer than cement (long enough to make diffusion-limited aggregation fractals).
VERB lava.* wall/. wall/basalt $T 0.01 set
VERB lava.* wall/basalt $T $T 1.0 set
# lava flows...
VERB lava.* _ $T lava/$F 0.3 flow
# lava flows slightly faster forwards, and slower backwards
VERB lava/$F _ $T lava/$F 0.4 flow
VERB lava/$L _ $T lava/$F 0.01 flow
VERB lava/$R _ $T lava/$F 0.01 flow
VERB lava/$+L _ $T lava/$F 0.0001 flow
VERB lava/$+R _ $T lava/$F 0.0001 flow
VERB lava/$++L _ $T lava/$F 0 flow
VERB lava/$++R _ $T lava/$F 0 flow
VERB lava/$B _ $T lava/$F 0 flow
VERB lava .* _ $T .00001 drain

# zoo guests do bugger all except stroll around the place and get mauled
VERB zoo_guest.* _ $T $S 0.01 perambulate


# conga line
# this models a simple polymer (e.g. a hydrocarbon) by creating energetically favored adjacencies between consecutive monomers
# the builder is directional to avoid intractable tangles (the polymer is initially stretched in a straight line, but quickly relaxes)
NOUN conga.* 128 192 192

# initial production rule:  conga -> conga_head/pos:$POS   where $POS \in { 10, 20, 30 }
# this (as you can probably guess) sets the length of the conga line at 10, 20 or 30
VERB conga .* conga_head/pos:10 $T .3 start_lil_conga
VERB conga .* conga_head/pos:20 $T .3 start_hapnin_conga
VERB conga .* conga_head/pos:30 $T .3 start_monsta_conga

# conga_head is the constructor
# its stateful form is  conga_head/pos:$POS,dir:$DIR  where $POS is an integer and $DIR a compass direction
# the first rule randomly picks $DIR
VERB conga_head/pos:(\d+) .* conga_head/dir:$F,pos:$1 $T 1 line_em_up
VERB conga_head/dir:$F,pos:([1-9]\d*) _ conga_dude/pos:$1 conga_head/dir:$F,pos:$-1 1 partay
VERB conga_head/dir:.*,pos:0 _ conga_dude/pos:0 _ 1 reach_the_end

# this is the energy term that effectively creates a covalent bond between consecutive monomers (conga_dude's)
# since the energy of this bond is -5, the probability of spontaneously breaking it is 1e-5
# thus, moves that break a bond will typically be rejected.
ENERGY conga.*[/,]pos:(\d+) conga.*[/,]pos:$+1 -5

# jiggle the conga guests at max speed, since most of their random steps are rejected anyway
VERB conga_dude.* _ $T $S 1 go_nuts
VERB conga_dude.* .* _ $T .001 expire


# RNA
# base colors: HSV values with S=1, V=0.5 & H depending on the nucleotide: 0(a), .25(c), .5(g), .75(u)
NOUN base_a.* 128 0 0
NOUN base_c.* 64 128 0
NOUN base_g.* 0 128 128
NOUN base_u.* 64 0 128

# basepairs: currently only Watson-Crick basepairs are allowed. colors are sums of individual bases.
NOUN basepair_(au|ua).* 192 0 128
NOUN basepair_(cg|gc).* 64 255 128

# internally, each base is represented as an integer variable x: 0(a), 1(c), 2(u), 3(g)
# note that a Watson-Crick pairing for x is (x+2)%4
VERB (base_a)([^x]*) .* $1/x:0$2 $T 1 /init_$1
VERB (base_c)([^x]*) .* $1/x:1$2 $T 1 /init_$1
VERB (base_u)([^x]*) .* $1/x:2$2 $T 1 /init_$1
VERB (base_g)([^x]*) .* $1/x:3$2 $T 1 /init_$1

# define the covalent bond between consecutive bases on the same chain
# chain variable is c; chain position is i
ENERGY base_.*/c:(\d+)/i:(\d+).* (RNA_sequence|base|basepair)_.*/c:$1/i:$+2/.* -10

# basepairs are more favorable than bases...
ENERGY basepair_.*/c:(\d+)/i:(\d+).* (RNA_sequence|base)_.*/c:$1/i:$+2/.* -11

# ...and stacked basepairs are more favorable still
# NB we have to specify the x->x and y->y linkages separately, because individual ENERGY rules only fire once (just like individual VERBs)
ENERGY basepair_[^y]*/c:(\d+)/i:(\d+).* basepair_[^y]*/c:$1/i:$+2/.* -12
ENERGY basepair_.*/c:(\d+)/i:(\d+)[^y]* basepair_.*/c:$1/i:$+2/[^y]* -12


# to make a basepair, merge two bases /x:... and /y:... as /x:.../y:...
VERB base_(.)/x:(\d)(.*) base_(.)/x:($%4+2.2)(.*) basepair_$1$4/x:$2$3/y:$5$6 _ 1 pair_$1_to_$4

# override the basepair move for nearby nucleotides in the same chain, so min loop length is 3
# These are commented out because entropy appears to work just fine to prevent this...? Also, verbs are expensive, so...
# upstream:
#VERB base_(.)/x:(\d)(.*)/c:(\d+)/i:(\d+)(.*) base_(.)/x:($%4+2.2)(.*)/c:($4)/i:($+2.5)(.*) basepair_$1$7/x:$2$3/c:$4/i:$5$6/y:$8$9/c:$10/i:$11$12 _ 0 pair_$1_to_$4
#VERB base_(.)/x:(\d)(.*)/c:(\d+)/i:(\d+)(.*) base_(.)/x:($%4+2.2)(.*)/c:($4)/i:($+3.5)(.*) basepair_$1$7/x:$2$3/c:$4/i:$5$6/y:$8$9/c:$10/i:$11$12 _ 0 pair_$1_to_$4
# downstream:
#VERB base_(.)/x:(\d)(.*)/c:(\d+)/i:(\d+)(.*) base_(.)/x:($%4+2.2)(.*)/c:($4)/i:($-2.5)(/.*|) basepair_$1$7/x:$2$3/c:$4/i:$5$6/y:$8$9/c:$10/i:$11$12 _ 0 pair_$1_to_$4
#VERB base_(.)/x:(\d)(.*)/c:(\d+)/i:(\d+)(.*) base_(.)/x:($%4+2.2)(.*)/c:($4)/i:($-3.5)(/.*|) basepair_$1$7/x:$2$3/c:$4/i:$5$6/y:$8$9/c:$10/i:$11$12 _ 0 pair_$1_to_$4

# unpairing is the opposite move: we have to pick apart the x and y blocks into two particles. tricky :)
VERB basepair_(.)(.)/x:(\d)(.*)/y:(\d)(.*) _ base_$1/x:$3$4 base_$2/x:$5$6 1 unpair_$1_from_$2


# all bases and basepairs do Brownian drift, subject to their energy constraints
VERB (base|basepair)_.* _ $T $S 1 /drift


# now here is the constructor for an RNA sequence
NOUN RNA_sequence_[acgu]* 0 0 255

# cycle randomly through chain IDs
VERB RNA_sequence_[acgu]+ .* $S/c:0 $T 1 /zero_chain_id

# cycle randomly through chain IDs 0...9
VERB (RNA_sequence_[acgu]+)/c:(\d) .* $1/c:$%10+1.2 $T 1 /rotate_chain_id

# pick a direction, d
# To prevent collisions, just set this to east for now; but could use d:$F
# also set i, the chain position index, to zero
# this rule is slow, to allow adequate sampling of chain IDs via the previous rule
VERB RNA_sequence_[acgu]+/c:\d .* $S/i:0/d:e $T .1 /pick_direction

# generate a base
VERB (RNA_sequence_[acgu]+)([acgu])(/c:\d/i:)(\d+)(/d:$F) _ base_$2$3$4/ $1$3$+4$5 1 generate_base_$2

# generate last base
VERB RNA_sequence_([acgu])(/c:\d/i:\d+)(/d:$F) _ base_$1$2$3 _ 1 generate_base_$1


# allow run-length encoding of RNA sequences
NOUN RNA_sequence_[acgu\d]* 0 255 255
VERB (RNA_sequence_[acgu]*)([acgu])(\d+)(.*) .* $1$2$2$-3$4 $T 1 /expand_run_length_encoding
# override run-length of 2:
VERB (RNA_sequence_[acgu]*)([acgu])(2)([^\d].*|) .* $1$2$2$-3$4 $T 0 /expand_run_length_encoding
VERB (RNA_sequence_[acgu]*)([acgu])(2)([^\d].*|) .* $1$2$2$4 $T 1 /expand_run_length_encoding


# end of rules
END
