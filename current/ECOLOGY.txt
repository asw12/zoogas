# The different colored species particles
# The species follow a simple (unrealistic) cyclic ecology.
# The species number is prefixed by "/s:".
NOUN n=_ c=000000
NOUN n=.*/s:0 c=ff0000
NOUN n=.*/s:1 c=ff5100
NOUN n=.*/s:2 c=ffa100
NOUN n=.*/s:3 c=fff200
NOUN n=.*/s:4 c=bcff00
NOUN n=.*/s:5 c=6bff00
NOUN n=.*/s:6 c=1bff00
NOUN n=.*/s:7 c=00ff36
NOUN n=.*/s:8 c=00ff86
NOUN n=.*/s:9 c=00ffd7
NOUN n=.*/s:10 c=00d7ff
NOUN n=.*/s:11 c=0086ff
NOUN n=.*/s:12 c=0036ff
NOUN n=.*/s:13 c=1b00ff
NOUN n=.*/s:14 c=6b00ff
NOUN n=.*/s:15 c=bc00ff
NOUN n=.*/s:16 c=ff00f2
NOUN n=.*/s:17 c=ff00a1

# The tools and behavior accessible to the player
NOUN n=wall/1 c=2b2b2b
NOUN n=wall/2 c=555555
NOUN n=wall/3 c=808080
NOUN n=wall/4 c=aaaaaa
NOUN n=wall/5 c=d5d5d5
NOUN n=cement c=ffffff
NOUN n=acid c=404040 e=-20
NOUN n=perfume c=804054
NOUN n=mutator c=ff80a8
NOUN n=lava c=ff6060
NOUN n=lava/.* c=e06060
NOUN n=wall/basalt c=ffc800
NOUN n=zoo_guest.* c=fefefe

# Beacon: an example directional particle
NOUN n=(beacon|photon).* c=c0c000
VERB s=beacon t=_ S=beacon T=photon/$F p=.5 v=shine
VERB s=beacon t=_ S=_ T=_ p=.01 v=extinguish
VERB s=photon/$F t=_ S=$T T=$S p=10 v=beam
VERB s=photon/$F t=[^_].* S=_ T=$T p=.9 v=absorb
VERB s=photon/$F t=[^_].* S=photon/$++L T=$T p=.1 v=reflect
VERB s=photon/$F t=[^_].* S=photon/$++R T=$T p=.05 v=reflect
# Without this last rule, photons at uncrossable borders will never die
VERB s=photon/$B t=.* S=_ T=$T p=.001 v=scatter

# Initial conditions
VERB s=/INIT.* S=beacon v=/start
#VERB s=/INIT.* S=_ v=/start
#VERB s=/INIT.* S=RNA_sequence_a20u20 v=/start

# Initial animals
NOUN n=animal c=0000ff
VERB s=animal S=rock_imp/s:0
VERB s=animal S=blade_beetle/s:6
VERB s=animal S=paper_bird/s:12

# Animal rules. This is where the ecology actually happens.
# Successful predation
VERB s=.*/s:0 t=.*/s:([1-9]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:1 t=.*/s:([2-9]|10) S=$S T=$S p=.024 v=eat
VERB s=.*/s:2 t=.*/s:([3-9]|1[0-1]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:3 t=.*/s:([4-9]|1[0-2]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:4 t=.*/s:([5-9]|1[0-3]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:5 t=.*/s:([6-9]|1[0-4]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:6 t=.*/s:([7-9]|1[0-5]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:7 t=.*/s:([8-9]|1[0-6]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:8 t=.*/s:(9|1[0-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:9 t=.*/s:(0|1[0-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:10 t=.*/s:([0-1]|1[1-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:11 t=.*/s:([0-2]|1[2-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:12 t=.*/s:([0-3]|1[3-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:13 t=.*/s:([0-4]|1[4-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:14 t=.*/s:([0-5]|1[5-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:15 t=.*/s:([0-6]|1[6-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:16 t=.*/s:([0-7]|17) S=$S T=$S p=.024 v=eat
VERB s=.*/s:17 t=.*/s:([0-8]) S=$S T=$S p=.024 v=eat

# Unsuccessful predation
VERB s=.*/s:0 t=.*/s:([1-9]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:1 t=.*/s:([2-9]|10) S=$S T=$S p=.006 v=kill
VERB s=.*/s:2 t=.*/s:([3-9]|1[0-1]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:3 t=.*/s:([4-9]|1[0-2]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:4 t=.*/s:([5-9]|1[0-3]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:5 t=.*/s:([6-9]|1[0-4]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:6 t=.*/s:([7-9]|1[0-5]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:7 t=.*/s:([8-9]|1[0-6]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:8 t=.*/s:(9|1[0-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:9 t=.*/s:(0|1[0-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:10 t=.*/s:([0-1]|1[1-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:11 t=.*/s:([0-2]|1[2-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:12 t=.*/s:([0-3]|1[3-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:13 t=.*/s:([0-4]|1[4-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:14 t=.*/s:([0-5]|1[5-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:15 t=.*/s:([0-6]|1[6-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:16 t=.*/s:([0-7]|17) S=$S T=$S p=.006 v=kill
VERB s=.*/s:17 t=.*/s:([0-8]) S=$S T=$S p=.006 v=kill

# Breeding, overcrowding
VERB s=.*/s:\d+ t=_ S=$S T=$S p=.0007 v=spawn
VERB s=.*/s:\d+ t=.*/s:\d+ S=_ T=$T p=0.0015 v=choke

# Movement is on von Neumann topology (so they can't escape through cracks)
VERB s=.*/s:\d+ t=_ S=$T T=$S p=0.02 v=step d=.

# Other behaviors of animals
# Animals eat guests:
VERB s=.*/s:\d+ t=zoo_guest.* S=_ T=$S p=1.0 v=maul
# Imps feed on lava:
VERB s=.*_imp/s:\d+ t=lava.* S=$S T=$S p=.01 v=frolic



# Walls and cement
VERB s=wall/([2-9a-z]) t=.* S=wall/$-1 T=$T p=.00022 v=decay
VERB s=wall/([2-9a-z]) t=wall.* S=wall/$-1 T=$T p=.00018 v=decay
VERB s=wall/([2-9a-z]) t=acid S=wall/$-1 T=$T p=0.001 v=decay
VERB s=wall/1 t=.* S=_ T=$T p=2.2E-4 v=decay
VERB s=wall/1 t=wall.* S=_ T=$T p=.00018 v=decay
VERB s=wall/1 t=acid S=_ T=$T p=0.001 v=decay
VERB s=cement t=[^_].* S=wall/4 T=$T p=0.2 v=set
VERB s=cement t=wall.* S=wall/4 T=$T p=0.9 v=stick
VERB s=cement t=_ S=$T T=$S p=.99 v=drift
VERB s=cement t=.* S=_ T=$T p=.01 v=drain


# Cage builders: a simple geometric program with nested loops (bricks/walls).
NOUN n=cage_builder.* c=8080c0
# Choose size and orientation:
VERB s=cage_builder t=.* S=cage_builder/len:5 T=$T p=.3 v=plan_small_cage
VERB s=cage_builder t=.* S=cage_builder/len:11 T=$T p=.3 v=plan_medium_cage
VERB s=cage_builder t=.* S=cage_builder/len:21 T=$T p=.3 v=plan_large_cage
VERB s=cage_builder/len:(\d+) t=.* S=cage_builder/len:$1/dir:$F T=$T p=1 v=choose_orientation
# Exclude diagonal cages (or animals can escape through the cracks)
VERB s=cage_builder/len:(\d+)/dir:(ne|nw|se|sw) t=.* S=cage_builder/len:$1/dir:$F T=$T p=1 v=rethink_orientation
# OK, here's the program that actually builds the cage. It's a simple state machine: build, turn, stop.
VERB s=cage_builder/len:(\d+)/dir:(.) t=.* S=cage_builder/len:$1/walls:3/steps:$1/dir:$2 T=$T p=1 v=start
VERB s=cage_builder/len:(\d+)/walls:(\d)/steps:([^0].*)/dir:$F t=_ S=wall/5 T=cage_builder/len:$1/walls:$2/steps:$-3/dir:$F p=1 v=place_next_brick
VERB s=cage_builder/len:(\d+)/walls:([^0])/steps:0/dir:$F t=.* S=cage_builder/len:$1/walls:$-2/steps:$1/dir:$+R T=$T p=1 v=build_next_wall
VERB s=cage_builder/len:(\d+)/walls:0/steps:[01]/dir:.* t=.* S=wall/5 T=$T p=1 v=finish
# Handle collisions gracefully:
VERB s=cage_builder/.*dir:$F t=(wall/.*|cage_builder.*) S=wall/5 T=$T p=1 v=join_wall
# Drop an animal every now and then:
VERB s=cage_builder/.*/dir:$+L t=_ T=animal v=seed p=.1


# uncomment the following to test for runaway particle names... (cage_builder discovered this bug, that's why it's here)
# VERB s=cage_builder/(.*) t=.* S=$S$1 T=$T p=1 v=example_regex_bug


# Acid dissolves everything; usually, it is then "used up"
VERB s=acid t=.* S=$S T=_ p=0.1 v=dissolve
VERB s=acid t=.* S=_ T=_ p=0.9 v=dissolve
# Override "Acid dissolves everything" rules for basalt, lava & empty space
VERB s=acid t=wall/basalt|lava|_ S=$S T=_ p=0.0 v=dissolve
VERB s=acid t=wall/basalt|lava|_ S=_ T=_ p=0.0 v=dissolve
# Instead, acid turns basalt into lava
VERB s=acid t=wall/basalt S=$S T=lava p=0.3 v=dissolve
# Acid does fast Brownian motion
VERB s=acid t=_ S=$T T=$S p=1.0 v=drift
VERB s=acid t=.* S=_ T=$T p=.005 v=drain

# Perfume
VERB s=perfume t=.*/s:\d+ S=$T T=$T p=1.0 v=hornify
VERB s=.*/s:\d+ t=perfume S=$S T=$S p=1.0 v=breed
VERB s=perfume t=_ S=_ T=$T p=0.1 v=disperse
VERB s=perfume t=_ S=$S T=$S p=0.09 v=billow
VERB s=perfume t=_ S=$T T=$S p=0.81 v=drift

# Mutator gas: change the species number.
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+1.2 p=1.0 v=mutate
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+17.2 p=1.0 v=mutate
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+2.2 p=0.1 v=mutate
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+16.2 p=0.1 v=mutate
VERB s=mutator t=_ S=_ T=_ p=0.1 v=disperse
VERB s=mutator t=_ S=$T T=$S p=0.9 v=drift
VERB s=mutator t=perfume S=$T T=$T p=1.0 v=react

# Generate random names for mutant animals
# form of mutant name is (adjective) (locale) (species)
VERB s=mutant/(.*) S=mutant_imp/$1
VERB s=mutant/(.*) S=mutant_beetle/$1
VERB s=mutant/(.*) S=mutant_bird/$1
VERB s=mutant/(.*) S=mutant_badger/$1
VERB s=mutant/(.*) S=mutant_kangaroo/$1
VERB s=mutant/(.*) S=mutant_panda/$1
VERB s=mutant/(.*) S=mutant_moth/$1
VERB s=mutant/(.*) S=mutant_cow/$1
VERB s=mutant/(.*) S=mutant_cat/$1
VERB s=mutant/(.*) S=mutant_wombat/$1
VERB s=mutant/(.*) S=mutant_elephant/$1
VERB s=mutant/(.*) S=mutant_wolf/$1
VERB s=mutant/(.*) S=mutant_pig/$1
VERB s=mutant/(.*) S=mutant_monkey/$1
VERB s=mutant/(.*) S=mutant_gorilla/$1
VERB s=mutant/(.*) S=mutant_chimp/$1
VERB s=mutant/(.*) S=mutant_meerkat/$1
VERB s=mutant/(.*) S=mutant_tick/$1
# avoid water 
VERB s=mutant_([^/_]+/.*) S=mutant_space_$1
VERB s=mutant_([^/_]+/.*) S=mutant_water_$1
VERB s=mutant_([^/_]+/.*) S=mutant_desert_$1
VERB s=mutant_([^/_]+/.*) S=mutant_cloud_$1
VERB s=mutant_([^/_]+/.*) S=mutant_shadow_$1
VERB s=mutant_([^/_]+/.*) S=mutant_dung_$1
VERB s=mutant_([^/_]+/.*) S=mutant_marsh_$1
VERB s=mutant_([^/_]+/.*) S=mutant_bistro_$1
VERB s=mutant_([^/_]+/.*) S=mutant_coffeeshop_$1
VERB s=mutant_([^/_]+/.*) S=mutant_schoolie_$1
VERB s=mutant_([^/_]+/.*) S=mutant_tundra_$1
# and, adjective
VERB s=mutant_([^/_]+_.*) S=lesser_spotted_$1
VERB s=mutant_([^/_]+_.*) S=greater_spotted_$1
VERB s=mutant_([^/_]+_.*) S=diffident_$1
VERB s=mutant_([^/_]+_.*) S=ironic_$1
VERB s=mutant_([^/_]+_.*) S=fierce_$1
VERB s=mutant_([^/_]+_.*) S=hooting_$1
VERB s=mutant_([^/_]+_.*) S=chirping_$1
VERB s=mutant_([^/_]+_.*) S=striped_$1
VERB s=mutant_([^/_]+_.*) S=luminous_$1
VERB s=mutant_([^/_]+_.*) S=horned_$1

# Lava. Sticks around longer than cement (long enough to make diffusion-limited aggregation fractals).
VERB s=lava.* t=wall/. S=wall/basalt T=$T p=0.01 v=set
VERB s=lava.* t=wall/basalt S=$T T=$T p=1.0 v=set
# lava flows...
VERB s=lava.* t=_ S=$T T=lava/$F p=0.3 v=flow
# lava flows slightly faster forwards, and slower backwards
VERB s=lava/$F t=_ S=$T T=lava/$F p=0.4 v=flow
VERB s=lava/$L t=_ S=$T T=lava/$F p=0.01 v=flow
VERB s=lava/$R t=_ S=$T T=lava/$F p=0.01 v=flow
VERB s=lava/$+L t=_ S=$T T=lava/$F p=0.0001 v=flow
VERB s=lava/$+R t=_ S=$T T=lava/$F p=0.0001 v=flow
VERB s=lava/$++L t=_ S=$T T=lava/$F p=0 v=flow
VERB s=lava/$++R t=_ S=$T T=lava/$F p=0 v=flow
VERB s=lava/$B t=_ S=$T T=lava/$F p=0 v=flow
VERB s=lava t=.* S=_ T=$T p=.00001 v=drain

# zoo guests do bugger all except stroll around the place and get mauled
VERB s=zoo_guest.* t=_ S=$T T=$S p=0.01 v=perambulate d=.


# conga line
# this models a simple polymer (e.g. a hydrocarbon) by creating energetically favored adjacencies between consecutive monomers
# the builder is directional to avoid intractable tangles (the polymer is initially stretched in a straight line, but quickly relaxes)
NOUN n=conga.* c=80c0c0 e=-10

# the energy terms that effectively create a covalent bond between consecutive monomers (conga_dude's)
BOND s=.*conga.* t=.*conga.* n=handsToHips e=+10 l=0 L=6 b=0
BOND s=.*conga.* t=.*conga.* n=handsToHips e=+5 l=0 L=6 b=0 m=0
# give the line a bit of rigidity
#BOND s=conga.* t=conga.* n=handsToHips e=+1 a=-.5 A=+.5 L=7.5
#BOND s=conga.* t=conga.* n=handsToHips e=+2 a=-.5 A=+.5 b=0 L=7.5
#BOND s=conga.* t=conga.* n=handsToHips e=+2 a=-.25 A=+.25 L=2
#BOND s=conga.* t=conga.* n=handsToHips e=+1 a=-.5 A=+.5 L=2 b=.5

# initial production rule:  conga -> conga_head/pos:$POS   where $POS \in { 10, 20, 30 }
# this (as you can probably guess) sets the length of the conga line at 10, 20 or 30
VERB s=conga t=.* S=conga_head/pos:10 T=$T p=.3 v=start_lil_conga
VERB s=conga t=.* S=conga_head/pos:20 T=$T p=.3 v=start_hapnin_conga
VERB s=conga t=.* S=conga_head/pos:30 T=$T p=.3 v=start_monsta_conga

# conga_head is the constructor
# its stateful form is  conga_head/pos:$POS/dir:$DIR  where $POS is an integer and $DIR a compass direction
# the first rule randomly picks $DIR
VERB s=conga_head/pos:(\d+) t=.* S=conga_head/dir:$F/pos:$1 T=$T p=1 v=line_em_up d=.
VERB s=conga_head/dir:$F/pos:([2-9]|\d\d+) t=_ S=conga_dude T=conga_head/dir:$F/pos:$-1 p=1 v=partay B=(s,handsToHips,t) k=(x,handsToHips,s)
VERB s=conga_head.* t=_ S=$T T=$S p=.01 v=wobble k=(sT,handsToHips,x) k=(y,handsToHips,sT)
VERB s=conga_head/dir:(.*)/pos:1 S=conga_dude p=1 v=lets_go k=(x,handsToHips,s)

# conga_dudes are wild and crazy
VERB s=conga_dude S=wild_conga_dude k=(x,handsToHips,s) k=(s,handsToHips,y)
VERB s=conga_dude S=crazy_conga_dude k=(x,handsToHips,s) k=(s,handsToHips,y)
NOUN n=crazy_conga_dude c=ffc0c0 e=-10
NOUN n=wild_conga_dude c=80c0ff e=-10

# jiggle the conga guests at max speed, since most of their random steps are rejected anyway
VERB s=.*conga_dude t=_ S=$T T=$S p=1 v=go_nuts k=(x,handsToHips,sT) k=(sT,handsToHips,y) d=.
VERB s=conga_.* S=_ p=.0001 v=expire

# birth-death on conga_dudes
VERB s=.*conga_dude t=_ S=$S T=$S p=.0001 v=conga_birth k=(x,handsToHips,s) K=(sT,handsToHips,y) B=(s,handsToHips,t)
VERB s=.*conga_dude t=.*conga_dude S=$S T=_ v=conga_death K=(x,handsToHips,s) c=(s,handsToHips,t) K=(tS,handsToHips,y)



# RNA
# base colors: HSV values with S=1, V=0.5 & H depending on the first nucleotide: 0(a), .25(c), .5(g), .75(u)
NOUN n=(base|RNA_sequence)_a.* c=800000 e=-10
NOUN n=(base|RNA_sequence)_c.* c=408000 e=-10
NOUN n=(base|RNA_sequence)_g.* c=008080 e=-10
NOUN n=(base|RNA_sequence)_u.* c=400080 e=-10

# canonical basepairs: RGB components are the the sums of the RGB components of individual bases.
# these lines also define the stabilizing energy of a Watson-Crick or wobble basepair
NOUN n=basepair_(cg|gc).* c=40ff80 e=-17
NOUN n=basepair_(au|ua).* c=c00080 e=-18
NOUN n=basepair_(gu|ug).* c=4080ff e=-19
# non-canonical basepairs are a bit dimmer (3/4 as bright as a straight sum).
# these lines also define the unfavorable energy of such basepairs
NOUN n=basepair_(ac|ca).* c=906000 e=-23
NOUN n=basepair_(ag|ga|cu|uc).* c=606060 e=-23
NOUN n=basepair_aa.* c=c00000 e=-23
NOUN n=basepair_cc.* c=60c000 e=-23
NOUN n=basepair_gg.* c=00c0c0 e=-23
NOUN n=basepair_uu.* c=6000c0 e=-23

# define the covalent bond between consecutive bases on the same chain
BOND n=5to3 s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=f5to3 s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=r5to3 s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=5to3f s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=5to3r s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=f5to3f s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=r5to3r s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10

# to make a basepair, merge two bases and their upstream(x) and downstream(y) bonds
VERB s=base_(.) t=base_(.) S=basepair_$1$2 T=_ p=1 v=pair_$1_to_$2 x=(s,5to3,t) x=(t,5to3,s) b=(s,5to3,xf) B=(s,f5to3,xf) b=(s,5to3f,xff) B=(s,f5to3f,xff) b=(yf,5to3,s) B=(yf,5to3f,s) b=(yff,f5to3,s) B=(yff,f5to3f,s) b=(t,5to3,xr) B=(s,r5to3,xr) b=(t,5to3r,xrr) B=(s,r5to3r,xrr) b=(yr,5to3,t) B=(yr,5to3r,s) b=(yrr,r5to3,t) B=(yrr,r5to3r,s)

# unpairing is the opposite move: we have to pick apart the -->x and y--> bonds
VERB s=basepair_(.)(.) t=_ S=base_$1 T=base_$2 p=1 v=unpair_$1_from_$2 b=(s,f5to3,xf) B=(s,5to3,xf) b=(s,f5to3f,xff) B=(s,5to3f,xff) b=(yf,5to3f,s) B=(yf,5to3,s) b=(yff,f5to3f,s) B=(yff,f5to3,s) b=(s,r5to3,xr) B=(t,5to3,xr) b=(s,r5to3r,xrr) B=(t,5to3r,xrr) b=(yr,5to3r,s) B=(yr,5to3,t) b=(yrr,r5to3r,s) B=(yrr,r5to3,t)

# all bases and basepairs do Brownian drift
VERB s=(base|basepair)_.* t=_ S=$T T=$S p=1 v=/drift k=(sT,5to3,x) k=(y,5to3,sT) k=(sT,5to3f,xf) k=(yf,5to3f,sT) k=(sT,f5to3,fx) k=(fy,f5to3,sT) k=(sT,f5to3f,xff) k=(yff,f5to3f,sT) k=(sT,r5to3,xr) k=(yr,r5to3,sT) k=(sT,5to3r,rx) k=(ry,5to3r,sT) k=(sT,r5to3r,xrr) k=(yrr,r5to3r,sT)

# all bases, basepairs and constructors will eventually disappear if they become unbonded
VERB s=(base|basepair)_.* S=_ p=.01 v=/degrade


# Photons mutate bases, preferring transitions to transversions
VERB s=photon/.* t=base_[ag] S=_ T=base_r p=.8 k=(x,5to3,t) k=(t,5to3,y)
VERB s=photon/.* t=base_[cu] S=_ T=base_y p=.8 k=(x,5to3,t) k=(t,5to3,y)
VERB s=photon/.* t=base_[acgu] S=_ T=base_n p=.2 k=(x,5to3,t) k=(t,5to3,y)
VERB s=base_r S=base_a k=(x,5to3,s) k=(s,5to3,y)
VERB s=base_r S=base_g k=(x,5to3,s) k=(s,5to3,y)
VERB s=base_y S=base_c k=(x,5to3,s) k=(s,5to3,y)
VERB s=base_y S=base_u k=(x,5to3,s) k=(s,5to3,y)
VERB s=base_n S=base_r k=(x,5to3,s) k=(s,5to3,y)
VERB s=base_n S=base_y k=(x,5to3,s) k=(s,5to3,y)


# now here is the constructor for an RNA sequence
# pick a direction, d
# To prevent collisions, just set this to east for now; but could use d:$F
# this rule is slow, to allow adequate sampling of chain IDs via the previous rule
VERB s=RNA_sequence_[acgu]+ t=.* S=$S/d:e T=$T p=.05 v=/pick_direction

# generate first base
VERB s=(RNA_sequence_)([acgu])([acgu]+)(/d:$F) t=_ S=base_$2 T=$1$3$4 p=1 v=generate_base_$2 B=(s,5to3,t) k=(x,5to3,s)

# generate last base
VERB s=(RNA_sequence_)([acgu])/.* t=.* S=base_$2 T=$T p=1 v=generate_last_base_$2 k=(x,5to3,s)


# allow run-length encoding of RNA sequences
# again with the blue/cyan pulsing
NOUN n=RNA_sequence_([acgu\d][acgu\d])* c=0000ff
NOUN n=RNA_sequence_[acgu\d]* c=00ffff
VERB s=(RNA_sequence_[acgu]*)([acgu])(\d+)(.*) t=.* S=$1$2$2$-3$4 T=$T p=1 v=/expand_run_length_encoding
# override run-length of 2:
VERB s=(RNA_sequence_[acgu]*)([acgu])(2)([^\d].*|) t=.* S=$1$2$2$-3$4 T=$T p=0 v=/expand_run_length_encoding
VERB s=(RNA_sequence_[acgu]*)([acgu])(2)([^\d].*|) t=.* S=$1$2$2$4 T=$T p=1 v=/expand_run_length_encoding



# Cell walls
NOUN n=(anchored_cell_wall|cell_builder.*) c=103010 e=-10
NOUN n=cell_wall c=204020 e=-10
BOND s=(anchored_|)cell_wall t=cell_(wall|builder.*) n=cellWall e=+10 L=1
VERB s=cell_wall t=_ S=$T T=$S k=(x,cellWall,sT) k=(sT,cellWall,y)
VERB s=(anchored_|)cell_wall S=_ p=.0001 v=degrade

# Cell builders
# Choose size and orientation:
VERB s=cell_builder t=.* S=cell_builder/len:5 T=$T p=.3 v=plan_small_cell
VERB s=cell_builder t=.* S=cell_builder/len:11 T=$T p=.3 v=plan_medium_cell
VERB s=cell_builder t=.* S=cell_builder/len:21 T=$T p=.3 v=plan_large_cell
VERB s=cell_builder/len:(\d+) t=.* S=cell_builder/len:$1/dir:$F T=$T p=1 v=choose_orientation d=.
# OK, here's the program that actually builds the cell. It's a simple state machine: build, turn, stop.
VERB s=cell_builder/len:(\d+)/dir:$F t=_ T=cell_builder/len:$1/walls:3/steps:$-1/dir:$F S=anchored_cell_wall v=start B=(s,cellWall,t)
VERB s=cell_builder/len:(\d+)/walls:(\d)/steps:([^0].*)/dir:$F t=_ S=cell_wall T=cell_builder/len:$1/walls:$2/steps:$-3/dir:$F v=place_next_brick k=(x,cellWall,s) B=(s,cellWall,t)
VERB s=cell_builder/len:(\d+)/walls:([^0])/steps:0/dir:$F S=cell_builder/len:$1/walls:$-2/steps:$1/dir:$+L v=build_next_wall k=(x,cellWall,s)
VERB s=cell_builder/len:(\d+)/walls:0/steps:0/dir:.* S=cell_wall v=finish k=(x,cellWall,s)
# Join up:
VERB s=cell_builder/.*dir:$F t=anchored_cell_wall S=cell_wall T=cell_wall p=1 v=join_wall k=(x,cellWall,s) k=(t,cellWall,y) B=(s,cellWall,t)
# Drop an animal every now and then:
VERB s=cell_builder/.*/dir:$+R t=_ T=animal v=seed p=.04

# Bombs throw off shrapnel...
NOUN n=(bomb|.*shrapnel).* c=00c080
VERB s=bomb S=bomb/r:2/n:3
VERB s=bomb/r:(\d)/n:([1-9]|\d\d+) S=bomb/r:$1/n:$-2 T=shrapnel/d:$F/v:$1 v=explode
VERB s=bomb/r:(\d)/n:0 S=shrapnel/d:$F/v:$1 v=explode

# shrapnel flies at various speeds (ugh, no way to specify this sort of match-dependent probability... yet)
VERB s=shrapnel/d:$F/v:9 p=9 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:8 p=8 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:7 p=7 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:6 p=6 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:5 p=5 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:4 p=4 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:3 p=3 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:2 p=2 t=_ S=$T T=$S v=fly
VERB s=shrapnel/d:$F/v:1 p=1 t=_ S=$T T=$S v=fly

# shrapnel deceleration, explosion, ricochet
VERB s=(shrapnel/d:$F/v:)([1-9]) t=_ S=$T T=$1$-2 v=fly/decelerate
VERB s=shrapnel/d:.*/v:[01] S=exploding_shrapnel p=.9 v=explode
VERB s=shrapnel/d:.*/.* t=[^_].* S=exploding_shrapnel v=explode
VERB s=shrapnel/d:$F/v:(\d) t=[^_].* S=shrapnel/d:$++L/v:$1 T=$T p=.1 v=ricochet
VERB s=shrapnel/d:$F/v:(\d) t=[^_].* S=shrapnel/d:$++R/v:$1 T=$T p=.05 v=ricochet
# Without this last rule, shrapnel at uncrossable borders will never die
VERB s=shrapnel/d:$B/v:.* t=.* S=_ T=$T p=.001 v=scatter

# exploding shrapnel either turns into fire, or throws off more shrapnel (using a bomb)
VERB s=exploding_shrapnel T=shrapnel/d:$F/v:1 p=.1
VERB s=exploding_shrapnel T=fire/e:5 p=.1
VERB s=exploding_shrapnel S=fire/e:9 p=.01

# Fire
NOUN n=fire/e:0 c=100000
NOUN n=fire/e:1 c=200000
NOUN n=fire/e:2 c=300000
NOUN n=fire/e:3 c=400000
NOUN n=fire/e:4 c=500000
NOUN n=fire/e:5 c=602000
NOUN n=fire/e:6 c=703000
NOUN n=fire/e:7 c=804000
NOUN n=fire/e:8 c=906000
NOUN n=fire/e:9 c=a08000
NOUN n=fire/e:10 c=b0a000
NOUN n=fire/e:11 c=c0c000
NOUN n=fire/e:12 c=d0d000
NOUN n=fire/e:13 c=e0e000
NOUN n=fire/e:14 c=f0f000
NOUN n=fire/e:15 c=ffff00

# spread quickly
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$+1 p=1 v=spread
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$1 p=1 v=spread
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$-1 p=1 v=spread
# override: spread more slowly if neighbor is open space
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$+1 t=_ p=0 v=spread
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$1 t=_ p=.05 v=spread
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$-1 t=_ p=.1 v=spread
# override: don't spread into fire ("rage" takes care of this, further down)
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$+1 t=fire/.* p=0 v=spread
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$1 t=fire/.* p=.05 v=spread
VERB s=fire/e:([1-9]|\d\d+) T=fire/e:$-1 t=fire/.* p=.1 v=spread
# rage/ebb/extinguish
VERB s=fire/e:([1-9]) t=fire/.* S=fire/e:$+1 p=.1 v=rage
VERB s=fire/e:([1-9]|\d\d+) S=fire/e:$-1 p=.15 v=ebb
VERB s=fire/e:0 S=_ p=.05 v=extinguish

# end of rules
END

