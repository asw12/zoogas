# The different colored species particles
# The species follow a simple (unrealistic) cyclic ecology.
# The species number is prefixed by "/s:".
NOUN n=_ c=000000
NOUN n=.*/s:0 c=ff0000
NOUN n=.*/s:1 c=ff5100
NOUN n=.*/s:2 c=ffa100
NOUN n=.*/s:3 c=fff200
NOUN n=.*/s:4 c=bcff00
NOUN n=.*/s:5 c=6bff00
NOUN n=.*/s:6 c=1bff00
NOUN n=.*/s:7 c=00ff36
NOUN n=.*/s:8 c=00ff86
NOUN n=.*/s:9 c=00ffd7
NOUN n=.*/s:10 c=00d7ff
NOUN n=.*/s:11 c=0086ff
NOUN n=.*/s:12 c=0036ff
NOUN n=.*/s:13 c=1b00ff
NOUN n=.*/s:14 c=6b00ff
NOUN n=.*/s:15 c=bc00ff
NOUN n=.*/s:16 c=ff00f2
NOUN n=.*/s:17 c=ff00a1

# The tools and behavior accessible to the player
NOUN n=wall/1 c=2b2b2b
NOUN n=wall/2 c=555555
NOUN n=wall/3 c=808080
NOUN n=wall/4 c=aaaaaa
NOUN n=wall/5 c=d5d5d5
NOUN n=cement c=ffffff
NOUN n=acid c=404040 e=-10
NOUN n=perfume c=804054
NOUN n=mutator c=ff80a8
NOUN n=lava c=ff6060
NOUN n=lava/.* c=e06060
NOUN n=wall/basalt c=ffc800
NOUN n=zoo_guest.* c=fefefe

# Beacon: an example directional particle
NOUN n=(beacon|photon).* c=c0c000
VERB s=beacon t=_ S=beacon T=photon/$F p=.5 v=shine
VERB s=beacon t=_ S=_ T=_ p=.01 v=extinguish
VERB s=photon/$F t=_ S=$T T=$S p=10 v=beam
VERB s=photon/$F t=[^_].* S=_ T=$T p=.9 v=absorb
VERB s=photon/$F t=[^_].* S=photon/$++L T=$T p=.1 v=reflect
VERB s=photon/$F t=[^_].* S=photon/$++R T=$T p=.05 v=reflect
# Without this last rule, photons at uncrossable borders will never die
VERB s=photon/$B t=.* S=_ T=$T p=.001 v=scatter

# Initial conditions
VERB s=/INIT.* t=_ S=beacon T=_ v=/start
#VERB s=/INIT.* t=_ S=_ T=_ v=/start

# Animal rules. This is where the ecology actually happens.
# Successful predation
VERB s=.*/s:0 t=.*/s:([1-9]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:1 t=.*/s:([2-9]|10) S=$S T=$S p=.024 v=eat
VERB s=.*/s:2 t=.*/s:([3-9]|1[0-1]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:3 t=.*/s:([4-9]|1[0-2]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:4 t=.*/s:([5-9]|1[0-3]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:5 t=.*/s:([6-9]|1[0-4]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:6 t=.*/s:([7-9]|1[0-5]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:7 t=.*/s:([8-9]|1[0-6]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:8 t=.*/s:(9|1[0-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:9 t=.*/s:(0|1[0-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:10 t=.*/s:([0-1]|1[1-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:11 t=.*/s:([0-2]|1[2-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:12 t=.*/s:([0-3]|1[3-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:13 t=.*/s:([0-4]|1[4-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:14 t=.*/s:([0-5]|1[5-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:15 t=.*/s:([0-6]|1[6-7]) S=$S T=$S p=.024 v=eat
VERB s=.*/s:16 t=.*/s:([0-7]|17) S=$S T=$S p=.024 v=eat
VERB s=.*/s:17 t=.*/s:([0-8]) S=$S T=$S p=.024 v=eat

# Unsuccessful predation
VERB s=.*/s:0 t=.*/s:([1-9]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:1 t=.*/s:([2-9]|10) S=$S T=$S p=.006 v=kill
VERB s=.*/s:2 t=.*/s:([3-9]|1[0-1]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:3 t=.*/s:([4-9]|1[0-2]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:4 t=.*/s:([5-9]|1[0-3]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:5 t=.*/s:([6-9]|1[0-4]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:6 t=.*/s:([7-9]|1[0-5]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:7 t=.*/s:([8-9]|1[0-6]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:8 t=.*/s:(9|1[0-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:9 t=.*/s:(0|1[0-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:10 t=.*/s:([0-1]|1[1-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:11 t=.*/s:([0-2]|1[2-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:12 t=.*/s:([0-3]|1[3-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:13 t=.*/s:([0-4]|1[4-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:14 t=.*/s:([0-5]|1[5-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:15 t=.*/s:([0-6]|1[6-7]) S=$S T=$S p=.006 v=kill
VERB s=.*/s:16 t=.*/s:([0-7]|17) S=$S T=$S p=.006 v=kill
VERB s=.*/s:17 t=.*/s:([0-8]) S=$S T=$S p=.006 v=kill

# Breeding, overcrowding
VERB s=.*/s:\d+ t=_ S=$S T=$S p=.0007 v=spawn
VERB s=.*/s:\d+ t=.*/s:\d+ S=_ T=$T p=0.0015 v=choke

# Movement
VERB s=.*/s:\d+ t=_ S=$T T=$S p=0.02 v=step

# Other behaviors of animals
# Animals eat guests:
VERB s=.*/s:\d+ t=zoo_guest.* S=_ T=$S p=1.0 v=maul
# Imps feed on lava:
VERB s=.*_imp/s:\d+ t=lava.* S=$S T=$S p=.01 v=frolic



# Walls and cement
VERB s=wall/([2-9a-z]) t=.* S=wall/$-1 T=$T p=.00022 v=decay
VERB s=wall/([2-9a-z]) t=wall.* S=wall/$-1 T=$T p=.00018 v=decay
VERB s=wall/([2-9a-z]) t=acid S=wall/$-1 T=$T p=0.001 v=decay
VERB s=wall/1 t=.* S=_ T=$T p=2.2E-4 v=decay
VERB s=wall/1 t=wall.* S=_ T=$T p=.00018 v=decay
VERB s=wall/1 t=acid S=_ T=$T p=0.001 v=decay
VERB s=cement t=[^_].* S=wall/4 T=$T p=0.2 v=set
VERB s=cement t=wall.* S=wall/4 T=$T p=0.9 v=stick
VERB s=cement t=_ S=$T T=$S p=.99 v=drift
VERB s=cement t=.* S=_ T=$T p=.01 v=drain


# Cage builders: a simple geometric program with nested loops (bricks/walls).
NOUN n=cage_builder.* c=8080c0
# Choose size and orientation:
VERB s=cage_builder t=.* S=cage_builder/len:5 T=$T p=.3 v=plan_small_cage
VERB s=cage_builder t=.* S=cage_builder/len:11 T=$T p=.3 v=plan_medium_cage
VERB s=cage_builder t=.* S=cage_builder/len:21 T=$T p=.3 v=plan_large_cage
VERB s=cage_builder/len:(\d+) t=.* S=cage_builder/len:$1/dir:$F T=$T p=1 v=choose_orientation
# Exclude diagonal cages (or animals can escape through the cracks)
VERB s=cage_builder/len:(\d+)/dir:(ne|nw|se|sw) t=.* S=cage_builder/len:$1/dir:$F T=$T p=1 v=rethink_orientation
# OK, here's the program that actually builds the cage. It's a simple state machine: build, turn, stop.
VERB s=cage_builder/len:(\d+)/dir:(.) t=.* S=cage_builder/len:$1/walls:3/steps:$1/dir:$2 T=$T p=1 v=start
VERB s=cage_builder/len:(\d+)/walls:(\d)/steps:([^0].*)/dir:$F t=_ S=wall/5 T=cage_builder/len:$1/walls:$2/steps:$-3/dir:$F p=1 v=place_next_brick
VERB s=cage_builder/len:(\d+)/walls:([^0])/steps:0/dir:$F t=.* S=cage_builder/len:$1/walls:$-2/steps:$1/dir:$+R T=$T p=1 v=build_next_wall
VERB s=cage_builder/len:(\d+)/walls:0/steps:[01]/dir:.* t=.* S=wall/5 T=$T p=1 v=finish
# Handle collisions gracefully:
VERB s=cage_builder/.*dir:$F t=(wall/.*|cage_builder.*) S=wall/5 T=$T p=1 v=join_wall


# uncomment the following to test for runaway particle names... (cage_builder discovered this bug, that's why it's here)
# VERB s=cage_builder/(.*) t=.* S=$S$1 T=$T p=1 v=example_regex_bug


# Acid dissolves everything; usually, it is then "used up"
VERB s=acid t=.* S=$S T=_ p=0.1 v=dissolve
VERB s=acid t=.* S=_ T=_ p=0.9 v=dissolve
# Override "Acid dissolves everything" rules for basalt, lava & empty space
VERB s=acid t=wall/basalt|lava|_ S=$S T=_ p=0.0 v=dissolve
VERB s=acid t=wall/basalt|lava|_ S=_ T=_ p=0.0 v=dissolve
# Instead, acid turns basalt into lava
VERB s=acid t=wall/basalt S=$S T=lava p=0.3 v=dissolve
# Acid does fast Brownian motion
VERB s=acid t=_ S=$T T=$S p=1.0 v=drift
VERB s=acid t=.* S=_ T=$T p=.005 v=drain

# Perfume
VERB s=perfume t=.*/s:\d+ S=$T T=$T p=1.0 v=hornify
VERB s=.*/s:\d+ t=perfume S=$S T=$S p=1.0 v=breed
VERB s=perfume t=_ S=_ T=$T p=0.1 v=disperse
VERB s=perfume t=_ S=$S T=$S p=0.09 v=billow
VERB s=perfume t=_ S=$T T=$S p=0.81 v=drift

# Mutator gas: change the species number.
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+1.2 p=1.0 v=mutate
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+17.2 p=1.0 v=mutate
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+2.2 p=0.1 v=mutate
VERB s=mutator t=(.*)/s:(\d+) S=_ T=mutant/s:$%18+16.2 p=0.1 v=mutate
VERB s=mutator t=_ S=_ T=_ p=0.1 v=disperse
VERB s=mutator t=_ S=$T T=$S p=0.9 v=drift
VERB s=mutator t=perfume S=$T T=$T p=1.0 v=react

# Lava. Sticks around longer than cement (long enough to make diffusion-limited aggregation fractals).
VERB s=lava.* t=wall/. S=wall/basalt T=$T p=0.01 v=set
VERB s=lava.* t=wall/basalt S=$T T=$T p=1.0 v=set
# lava flows...
VERB s=lava.* t=_ S=$T T=lava/$F p=0.3 v=flow
# lava flows slightly faster forwards, and slower backwards
VERB s=lava/$F t=_ S=$T T=lava/$F p=0.4 v=flow
VERB s=lava/$L t=_ S=$T T=lava/$F p=0.01 v=flow
VERB s=lava/$R t=_ S=$T T=lava/$F p=0.01 v=flow
VERB s=lava/$+L t=_ S=$T T=lava/$F p=0.0001 v=flow
VERB s=lava/$+R t=_ S=$T T=lava/$F p=0.0001 v=flow
VERB s=lava/$++L t=_ S=$T T=lava/$F p=0 v=flow
VERB s=lava/$++R t=_ S=$T T=lava/$F p=0 v=flow
VERB s=lava/$B t=_ S=$T T=lava/$F p=0 v=flow
VERB s=lava t=.* S=_ T=$T p=.00001 v=drain

# zoo guests do bugger all except stroll around the place and get mauled
VERB s=zoo_guest.* t=_ S=$T T=$S p=0.01 v=perambulate d=.


# conga line
# this models a simple polymer (e.g. a hydrocarbon) by creating energetically favored adjacencies between consecutive monomers
# the builder is directional to avoid intractable tangles (the polymer is initially stretched in a straight line, but quickly relaxes)
NOUN n=conga.* c=80c0c0 e=-10

# the energy terms that effectively create a covalent bond between consecutive monomers (conga_dude's)
BOND s=conga.* t=conga.* n=handsToHips e=+10 l=0 L=6 b=0
BOND s=conga.* t=conga.* n=handsToHips e=+5 l=0 L=6 b=0 m=0
# give the line a bit of rigidity
#BOND s=conga.* t=conga.* n=handsToHips e=+1 a=-.5 A=+.5 L=7.5
#BOND s=conga.* t=conga.* n=handsToHips e=+2 a=-.5 A=+.5 b=0 L=7.5
#BOND s=conga.* t=conga.* n=handsToHips e=+2 a=-.25 A=+.25 L=2
#BOND s=conga.* t=conga.* n=handsToHips e=+1 a=-.5 A=+.5 L=2 b=.5

# initial production rule:  conga -> conga_head/pos:$POS   where $POS \in { 10, 20, 30 }
# this (as you can probably guess) sets the length of the conga line at 10, 20 or 30
VERB s=conga t=.* S=conga_head/pos:10 T=$T p=.3 v=start_lil_conga
VERB s=conga t=.* S=conga_head/pos:20 T=$T p=.3 v=start_hapnin_conga
VERB s=conga t=.* S=conga_head/pos:30 T=$T p=.3 v=start_monsta_conga

# conga_head is the constructor
# its stateful form is  conga_head/pos:$POS/dir:$DIR  where $POS is an integer and $DIR a compass direction
# the first rule randomly picks $DIR
#VERB s=conga_head/pos:(\d+) t=.* S=conga_head/dir:$F/pos:$1 T=$T p=1 v=line_em_up
VERB s=conga_head/pos:(\d+) t=.* S=conga_head/dir:$F/pos:$1 T=$T p=1 v=line_em_up d=.
VERB s=conga_head/dir:$F/pos:([2-9]|\d\d+) t=_ S=conga_dude T=conga_head/dir:$F/pos:$-1 p=1 v=partay B=(s,handsToHips,t) k=(x,handsToHips,s)
VERB s=conga_head/dir:(.*)/pos:1 S=conga_dude p=1 v=lets_go k=(x,handsToHips,s)

# jiggle the conga guests at max speed, since most of their random steps are rejected anyway
VERB s=conga_dude t=_ S=$T T=$S p=1 v=go_nuts k=(x,handsToHips,sT) k=(sT,handsToHips,y) d=.
VERB s=conga_.* S=_ p=.0001 v=expire

# birth-death on conga_dudes
#VERB s=conga_dude t=_ S=$S T=$S p=.0001 v=conga_birth k=(x,handsToHips,s) k=(sT,handsToHips,y) B=(s,handsToHips,t)
#VERB s=conga_dude t=conga_dude S=$S T=_ p=.01 v=conga_death k=(x,handsToHips,s) k=(tS,handsToHips,y)



# RNA
# base colors: HSV values with S=1, V=0.5 & H depending on the first nucleotide: 0(a), .25(c), .5(g), .75(u)
NOUN n=(base|RNA_sequence)_a.* c=800000
NOUN n=(base|RNA_sequence)_c.* c=408000
NOUN n=(base|RNA_sequence)_g.* c=008080
NOUN n=(base|RNA_sequence)_u.* c=400080

# canonical basepairs: RGB components are the the sums of the RGB components of individual bases.
# these lines also define the stabilizing energy of a Watson-Crick or wobble basepair
NOUN n=basepair_(au|ua).* c=c00080 e=.5
NOUN n=basepair_(cg|gc).* c=40ff80 e=.5
NOUN n=basepair_(gu|ug).* c=4080ff e=.2
# non-canonical basepairs are a bit dimmer (3/4 as bright as a straight sum).
# these lines also define the unfavorable energy of such basepairs
NOUN n=basepair_(ac|ca).* c=906000 e=-1
NOUN n=basepair_(ag|ga|cu|uc).* c=606060 e=-1
NOUN n=basepair_aa.* c=c00000 e=-1
NOUN n=basepair_cc.* c=60c000 e=-1
NOUN n=basepair_gg.* c=00c0c0 e=-1
NOUN n=basepair_uu.* c=6000c0 e=-1

# define the covalent bond between consecutive bases on the same chain
# bond endpoint identifiers are /5p and /3p
# start with base->...
BOND n=5to3 s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=f5to3 s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10
BOND n=r5to3 s=(RNA_sequence|base|basepair)_.* t=(RNA_sequence|base|basepair)_.* e=+10

# to make a basepair, merge two bases and their upstream(x) and downstream(y) bonds
VERB s=base_(.) t=base_(.) S=basepair_$1$2 T=_ p=1 v=pair_$1_to_$2 x=(s,5to3,t) x=(t,5to3,s) b=(s,5to3,xf) B=(s,f5to3,xf) b=(yf,5to3,s) B=(yf,f5to3,s) b=(t,5to3,xr) B=(s,r5to3,xr) b=(yr,5to3,t) B=(yr,r5to3,s)

# unpairing is the opposite move: we have to pick apart the x and y bonds
VERB s=basepair_(.)(.) t=_ S=base_$1 T=base_$2 p=1 v=unpair_$1_from_$2 b=(s,f5to3,xf) B=(s,5to3,xf) b=(yf,f5to3,s) B=(yf,5to3,s) b=(s,r5to3,xr) B=(t,5to3,xr) b=(yr,r5to3,s) B=(yr,5to3,t)

# all bases and basepairs do Brownian drift
VERB s=(base|basepair)_.* t=_ S=$T T=$S p=1 v=/drift k=(sT,5to3,x) k=(y,5to3,sT) k=(sT,f5to3,xf) k=(yf,f5to3,sT) k=(sT,r5to3,xr) k=(yr,r5to3,sT)

# all bases, basepairs and constructors will eventually disappear if they become unbonded
VERB s=(base|basepair)_.* S=_ p=.01 v=/degrade


# now here is the constructor for an RNA sequence
# pick a direction, d
# To prevent collisions, just set this to east for now; but could use d:$F
# this rule is slow, to allow adequate sampling of chain IDs via the previous rule
VERB s=RNA_sequence_[acgu]+ t=.* S=$S/d:e T=$T p=.05 v=/pick_direction

# generate first base
VERB s=(RNA_sequence_)([acgu])([acgu]+)(/d:$F) t=_ S=base_$2 T=$1$3$4 p=1 v=generate_base_$2 B=(s,5to3,t) k=(x,5to3,s)

# generate last base
VERB s=(RNA_sequence_)([acgu])/.* t=.* S=base_$2 T=$T p=1 v=generate_last_base_$2 k=(x,5to3,s)


# allow run-length encoding of RNA sequences
# again with the blue/cyan pulsing
NOUN n=RNA_sequence_([acgu\d][acgu\d])* c=0000ff
NOUN n=RNA_sequence_[acgu\d]* c=00ffff
VERB s=(RNA_sequence_[acgu]*)([acgu])(\d+)(.*) t=.* S=$1$2$2$-3$4 T=$T p=1 v=/expand_run_length_encoding
# override run-length of 2:
VERB s=(RNA_sequence_[acgu]*)([acgu])(2)([^\d].*|) t=.* S=$1$2$2$-3$4 T=$T p=0 v=/expand_run_length_encoding
VERB s=(RNA_sequence_[acgu]*)([acgu])(2)([^\d].*|) t=.* S=$1$2$2$4 T=$T p=1 v=/expand_run_length_encoding


# end of rules
END

