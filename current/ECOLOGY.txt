# The different colored species particles
# The species follow a simple (unrealistic) cyclic ecology.
# The species character (an alphadecimal number from 0 to h, so there are eighteen species in total) is prefixed by "/=".
NOUN _ 0 0 0
NOUN .*/=0 255 0 0
NOUN .*/=1 255 81 0
NOUN .*/=2 255 161 0
NOUN .*/=3 255 242 0
NOUN .*/=4 188 255 0
NOUN .*/=5 107 255 0
NOUN .*/=6 27 255 0
NOUN .*/=7 0 255 54
NOUN .*/=8 0 255 134
NOUN .*/=9 0 255 215
NOUN .*/=a 0 215 255
NOUN .*/=b 0 134 255
NOUN .*/=c 0 54 255
NOUN .*/=d 27 0 255
NOUN .*/=e 107 0 255
NOUN .*/=f 188 0 255
NOUN .*/=g 255 0 242
NOUN .*/=h 255 0 161

# The tools and behavior accessible to the player
NOUN wall/1 43 43 43
NOUN wall/2 85 85 85
NOUN wall/3 128 128 128
NOUN wall/4 170 170 170
NOUN wall/5 213 213 213
NOUN cement 255 255 255
NOUN acid 64 64 64
NOUN perfume 128 64 84
NOUN mutator 255 128 168
NOUN lava 255 96 96
NOUN lava/.* 224 96 96
NOUN wall/basalt 255 200 0
NOUN zoo_guest 254 254 254

# Beacon: an example directional particle
NOUN beacon.* 192 192 0
VERB beacon _ beacon beacon/$F .5 shine
VERB beacon _ _ _ .01 extinguish
VERB beacon/$F _ $T $S 1 move
VERB beacon/$F [^_].* _ $T .9 extinguish
VERB beacon/$F [^_].* beacon/$++L $T .1 reflect
VERB beacon/$F [^_].* beacon/$++R $T .05 reflect
# Without this last rule, beacons at uncrossable borders will never die
VERB beacon/$B .* _ $T .001 extinguish

# Initial conditions
VERB /INIT.* _ beacon _ 1 start

# Animal rules. This is where the ecology actually happens.
# Successful predation
VERB .*/=(.) .*/=$%i+1.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+2.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+3.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+4.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+5.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+6.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+7.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+8.1 $S $S .024 eat
VERB .*/=(.) .*/=$%i+9.1 $S $S .024 eat

# Unsuccessful predation
VERB .*/=(.) .*/=$%i+1.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+2.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+3.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+4.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+5.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+6.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+7.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+8.1 $S _ .006 kill
VERB .*/=(.) .*/=$%i+9.1 $S _ .006 kill

# Breeding, overcrowding
VERB .*/=. _ $S $S .0007 spawn
VERB .*/=. .*/=. _ $T 0.0015 choke

# Movement
VERB .*/=. _ $T $S 0.02 step

# Other fun behaviors of animals
VERB .*/=. zoo_guest _ $S 1.0 maul
# Only [non-mutant] imps can destroy lava:
VERB .*imp/=. lava.* _ $T 1 frolic



# Walls and cement
VERB wall/([2-9a-z]) .* wall/$-1 $T .00022 decay
VERB wall/([2-9a-z]) wall.* wall/$-1 $T .00018 decay
VERB wall/([2-9a-z]) acid wall/$-1 $T 0.001 decay
VERB wall/1 .* _ $T 2.2E-4 decay
VERB wall/1 wall.* _ $T .00018 decay
VERB wall/1 acid _ $T 0.001 decay
VERB cement [^_].* wall/4 $T 0.2 set
VERB cement wall.* wall/4 $T 0.9 stick
VERB cement _ $T $S .99 drift
VERB cement .* _ $T .01 drain


# Cage builders: a simple geometric program with nested loops (bricks/walls).
NOUN cage_builder.* 128 128 192
# Choose size and orientation:
VERB cage_builder .* cage_builder/len:5 $T .3 plan_small_cage
VERB cage_builder .* cage_builder/len:b $T .3 plan_medium_cage
VERB cage_builder .* cage_builder/len:k $T .3 plan_large_cage
VERB cage_builder/len:([^,]*) .* cage_builder/len:$1,dir:$F $T 1 choose_orientation
# Exclude diagonal cages (or animals can escape through the cracks)
VERB cage_builder/len:([^,]*),dir:(ne|nw|se|sw) .* cage_builder/len:$1,dir:$F $T 1 rethink_orientation
# OK, here's the program that actually builds the cage. It's a simple state machine: build, turn, stop.
VERB cage_builder/len:([^,]*),dir:([^,]) .* cage_builder/len:$1,walls:3,steps:$1,dir:$2 $T 1 start
VERB cage_builder/len:(.*),walls:(.),steps:([^0].*),dir:$F _ wall/5 cage_builder/len:$1,walls:$2,steps:$-3,dir:$F 1 place_next_brick
VERB cage_builder/len:(.*),walls:([^0]),steps:0,dir:$F .* cage_builder/len:$1,walls:$-2,steps:$1,dir:$+R $T 1 build_next_wall
VERB cage_builder/len:(.*),walls:0,steps:[01],dir:.* .* wall/5 $T 1 finish
# Handle collisions gracefully:
VERB cage_builder/.*dir:$F wall/.*|cage_builder.* wall/5 $T 1 join_wall


# uncomment the following to test for runaway particle names... (cage_builder discovered this bug, that's why it's here)
# VERB cage_builder/(.*) .* $S$1 $T 1 example_regex_bug


# Acid dissolves everything; usually, it is then "used up"
VERB acid .* $S _ 0.1 dissolve
VERB acid .* _ _ 0.9 dissolve
# Override "Acid dissolves everything" rules for basalt, lava & empty space
VERB acid wall/basalt|lava|_ $S _ 0.0 dissolve
VERB acid wall/basalt|lava|_ _ _ 0.0 dissolve
# Instead, acid turns basalt into lava
VERB acid wall/basalt $S lava 0.3 dissolve
# Acid does fast Brownian motion
VERB acid _ $T $S 1.0 drift
VERB acid .* _ $T .005 drain

# Perfume
VERB perfume .*/=.* $T $T 1.0 hornify
VERB .*/=.* perfume $S $S 1.0 breed
VERB perfume _ _ $T 0.1 disperse
VERB perfume _ $S $S 0.09 billow
VERB perfume _ $T $S 0.81 drift

# Mutator gas: change the species number.
VERB mutator (.*)/=([0-9a-z]) _ mutant/=$%i+1.2 1.0 mutate
VERB mutator (.*)/=([0-9a-z]) _ mutant/=$%i+h.2 1.0 mutate
VERB mutator (.*)/=([0-9a-z]) _ mutant/=$%i+2.2 0.1 mutate
VERB mutator (.*)/=([0-9a-z]) _ mutant/=$%i+g.2 0.1 mutate
VERB mutator _ _ _ 0.1 disperse
VERB mutator _ $T $S 0.9 drift
VERB mutator perfume $T $T 1.0 react

# Lava. Sticks around longer than cement (long enough to make diffusion-limited aggregation fractals).
VERB lava.* wall/. wall/basalt $T 0.01 set
VERB lava.* wall/basalt $T $T 1.0 set
# lava flows...
VERB lava.* _ $T lava/$F 0.3 flow
# lava flows slightly faster forwards, and slower backwards
VERB lava/$F _ $T lava/$F 0.4 flow
VERB lava/$L _ $T lava/$F 0.01 flow
VERB lava/$R _ $T lava/$F 0.01 flow
VERB lava/$+L _ $T lava/$F 0.0001 flow
VERB lava/$+R _ $T lava/$F 0.0001 flow
VERB lava/$++L _ $T lava/$F 0 flow
VERB lava/$++R _ $T lava/$F 0 flow
VERB lava/$B _ $T lava/$F 0 flow
VERB lava .* _ $T .00001 drain

# zoo guests do bugger all except stroll around the place and get mauled
VERB zoo_guest _ $T $S 0.01 perambulate

END
